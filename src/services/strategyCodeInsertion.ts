
export class StrategyCodeInsertion {
  static insertCodeSnippet(existingCode: string, snippet: string, title: string): string {
    console.log('Inserting code snippet:', { title, snippet: snippet.substring(0, 100) + '...' });
    
    if (!existingCode.trim()) {
      return this.createBasicStrategyWithSnippet(snippet, title);
    }

    // Check if snippet already exists to prevent duplicates
    const snippetCore = snippet.trim().split('\n')[0].trim();
    if (existingCode.includes(snippetCore)) {
      console.log('Snippet already exists, skipping');
      return existingCode;
    }

    // Find the strategy_logic function and intelligently integrate the snippet
    const functionMatch = existingCode.match(/def strategy_logic\(data\):([\s\S]*?)(?=\n\ndef|\n# Alternative|\n$|$)/);
    
    if (functionMatch) {
      // Handle different types of recommendations with actual logic replacement
      if (title.includes('Trend Filter') || title.includes('Add Trend')) {
        return this.integrateTrendFilterLogic(existingCode, snippet, functionMatch);
      } else if (title.includes('Trailing Stop') || title.includes('Exit Strategy')) {
        return this.integrateExitStrategyLogic(existingCode, snippet, functionMatch);
      } else if (title.includes('Position Size') || title.includes('Risk')) {
        return this.integrateRiskManagementLogic(existingCode, snippet, functionMatch);
      } else if (title.includes('Volatility') || title.includes('Filter')) {
        return this.integrateVolatilityFilterLogic(existingCode, snippet, functionMatch);
      } else {
        return this.integrateGenericLogic(existingCode, snippet, title, functionMatch);
      }
    } else {
      return `${existingCode}

# ${title} (Strategy Coach Enhancement)
# ${snippet}`;
    }
  }

  private static createBasicStrategyWithSnippet(snippet: string, title: string): string {
    return `# Enhanced Strategy with ${title}
# Generated by Strategy Coach

def strategy_logic(data):
    # ${title}
    ${snippet}
    
    # Enhanced entry/exit logic
    entry = []
    exit = []
    
    for i in range(len(data)):
        if i == 0:
            entry.append(False)
            exit.append(False)
        else:
            # Apply enhanced logic
            entry_condition = short_ema[i] > long_ema[i] and trend_up if 'trend_up' in locals() else short_ema[i] > long_ema[i]
            exit_condition = short_ema[i] < long_ema[i] or (position and 'trailing_stop' in locals() and data['Close'][i] < trailing_stop)
            
            entry.append(entry_condition and short_ema[i-1] <= long_ema[i-1])
            exit.append(exit_condition and short_ema[i-1] >= long_ema[i-1])
    
    return {
        'entry': entry,
        'exit': exit
    }`;
  }

  private static integrateTrendFilterLogic(code: string, snippet: string, functionMatch: RegExpMatchArray): string {
    // Replace the entire entry logic with trend-filtered version
    const entryPattern = /(entry_signal\s*=.*?)(\n)/;
    const entryMatch = functionMatch[1].match(entryPattern);
    
    if (entryMatch) {
      const enhancedEntry = `    # Trend filter enhancement
    ${snippet.replace(/\n/g, '\n    ')}
    
    # Enhanced entry with trend filter
    entry_signal = ${entryMatch[1].replace('entry_signal = ', '')} and trend_up`;
      
      return code.replace(entryMatch[0], enhancedEntry + '\n');
    }
    
    // If no existing entry signal, add it before the loop
    const loopPattern = /(\s+)(for i in range\(len\(data\)\):)/;
    const loopMatch = functionMatch[1].match(loopPattern);
    
    if (loopMatch) {
      const enhancedCode = `${loopMatch[1]}# Trend filter enhancement
${loopMatch[1]}${snippet.replace(/\n/g, '\n' + loopMatch[1])}
${loopMatch[1]}
${loopMatch[0]}`;
      
      return code.replace(loopMatch[0], enhancedCode);
    }
    
    return code;
  }

  private static integrateExitStrategyLogic(code: string, snippet: string, functionMatch: RegExpMatchArray): string {
    // Look for exit logic and enhance it
    const exitPattern = /(exit_signal\s*=.*?)(\n)/;
    const exitMatch = functionMatch[1].match(exitPattern);
    
    if (exitMatch) {
      const enhancedExit = `    # Enhanced exit strategy
    ${snippet.replace(/\n/g, '\n    ')}
    
    # Enhanced exit with trailing stop
    exit_signal = ${exitMatch[1].replace('exit_signal = ', '')} or (position and current_price < trailing_stop)`;
      
      return code.replace(exitMatch[0], enhancedExit + '\n');
    }
    
    // Add before the loop if no exit logic exists
    const loopPattern = /(\s+)(for i in range\(len\(data\)\):)/;
    const loopMatch = functionMatch[1].match(loopPattern);
    
    if (loopMatch) {
      const enhancedCode = `${loopMatch[1]}# Enhanced exit strategy
${loopMatch[1]}${snippet.replace(/\n/g, '\n' + loopMatch[1])}
${loopMatch[1]}
${loopMatch[0]}`;
      
      return code.replace(loopMatch[0], enhancedCode);
    }
    
    return code;
  }

  private static integrateRiskManagementLogic(code: string, snippet: string, functionMatch: RegExpMatchArray): string {
    // Insert risk management at the beginning of the function
    const functionStart = /def strategy_logic\(data\):\s*\n/;
    const riskCode = `def strategy_logic(data):
    # Risk Management Enhancement
    ${snippet.replace(/\n/g, '\n    ')}
    `;
    
    return code.replace(functionStart, riskCode);
  }

  private static integrateVolatilityFilterLogic(code: string, snippet: string, functionMatch: RegExpMatchArray): string {
    // Add volatility filter to entry conditions
    const entryPattern = /(entry_signal\s*=.*?)(\n)/;
    const entryMatch = functionMatch[1].match(entryPattern);
    
    if (entryMatch) {
      const enhancedEntry = `    # Volatility filter
    ${snippet.replace(/\n/g, '\n    ')}
    
    # Entry with volatility filter
    entry_signal = ${entryMatch[1].replace('entry_signal = ', '')} and volatility_threshold`;
      
      return code.replace(entryMatch[0], enhancedEntry + '\n');
    }
    
    return code;
  }

  private static integrateGenericLogic(code: string, snippet: string, title: string, functionMatch: RegExpMatchArray): string {
    // Insert before the main logic
    const loopPattern = /(\s+)(for i in range\(len\(data\)\):)/;
    const loopMatch = functionMatch[1].match(loopPattern);
    
    if (loopMatch) {
      const enhancedCode = `${loopMatch[1]}# ${title} Enhancement
${loopMatch[1]}${snippet.replace(/\n/g, '\n' + loopMatch[1])}
${loopMatch[1]}
${loopMatch[0]}`;
      
      return code.replace(loopMatch[0], enhancedCode);
    }
    
    return code;
  }

  static insertMultipleSnippets(existingCode: string, snippets: Array<{code: string, title: string}>): string {
    let updatedCode = existingCode;
    
    snippets.forEach((snippet, index) => {
      console.log(`Inserting snippet ${index + 1}/${snippets.length}: ${snippet.title}`);
      updatedCode = this.insertCodeSnippet(updatedCode, snippet.code, snippet.title);
    });
    
    return updatedCode;
  }
}
