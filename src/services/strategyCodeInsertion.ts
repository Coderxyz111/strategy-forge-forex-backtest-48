
export class StrategyCodeInsertion {
  static insertCodeSnippet(existingCode: string, snippet: string, title: string): string {
    console.log('Inserting code snippet:', { title, snippet: snippet.substring(0, 100) + '...' });
    
    if (!existingCode.trim()) {
      return this.createBasicStrategyWithSnippet(snippet, title);
    }

    // Check if snippet already exists to prevent duplicates
    const snippetCore = snippet.trim().split('\n')[0].trim();
    if (existingCode.includes(snippetCore)) {
      console.log('Snippet already exists, skipping');
      return existingCode;
    }

    // Find the strategy_logic function and intelligently integrate the snippet
    const functionMatch = existingCode.match(/def strategy_logic\(data\):([\s\S]*?)(?=\n\ndef|\n# Alternative|\n$|$)/);
    
    if (functionMatch) {
      // Handle different types of recommendations with actual logic replacement
      if (title.includes('Trend Filter') || title.includes('Add Trend')) {
        return this.integrateTrendFilterLogic(existingCode, snippet, functionMatch);
      } else if (title.includes('Trailing Stop') || title.includes('Exit Strategy')) {
        return this.integrateExitStrategyLogic(existingCode, snippet, functionMatch);
      } else if (title.includes('Position Size') || title.includes('Risk')) {
        return this.integrateRiskManagementLogic(existingCode, snippet, functionMatch);
      } else if (title.includes('Volatility') || title.includes('Filter')) {
        return this.integrateVolatilityFilterLogic(existingCode, snippet, functionMatch);
      } else if (title.includes('Dynamic Stop Loss')) {
        return this.integrateDynamicStopLossLogic(existingCode, snippet, functionMatch);
      } else {
        return this.integrateGenericLogic(existingCode, snippet, title, functionMatch);
      }
    } else {
      return `${existingCode}

# ${title} (Strategy Coach Enhancement)
${snippet}`;
    }
  }

  private static createBasicStrategyWithSnippet(snippet: string, title: string): string {
    return `# Enhanced Strategy with ${title}
# Generated by Strategy Coach

def strategy_logic(data):
    # Calculate EMAs using the TechnicalAnalysis helper
    short_ema = TechnicalAnalysis.ema(data['Close'].tolist(), 12)
    long_ema = TechnicalAnalysis.ema(data['Close'].tolist(), 26)
    
    # ${title}
    ${snippet}
    
    # Enhanced entry/exit logic
    entry = []
    exit = []
    
    for i in range(len(data)):
        if i == 0:
            entry.append(False)
            exit.append(False)
        else:
            # Apply enhanced logic with recommendation
            entry_condition = short_ema[i] > long_ema[i] and short_ema[i-1] <= long_ema[i-1]
            exit_condition = short_ema[i] < long_ema[i] and short_ema[i-1] >= long_ema[i-1]
            
            # Apply trend filter if available
            if 'trend_up' in locals():
                entry_condition = entry_condition and trend_up[i] if i < len(trend_up) else entry_condition
            
            # Apply volatility filter if available
            if 'volatility_threshold' in locals():
                entry_condition = entry_condition and volatility_threshold[i] if i < len(volatility_threshold) else entry_condition
            
            entry.append(entry_condition)
            exit.append(exit_condition)
    
    return {
        'entry': entry,
        'exit': exit,
        'short_ema': short_ema,
        'long_ema': long_ema
    }`;
  }

  private static integrateTrendFilterLogic(code: string, snippet: string, functionMatch: RegExpMatchArray): string {
    // Insert after EMA calculations but before the main loop
    const emaPattern = /(long_ema = TechnicalAnalysis\.ema\(data\['Close'\]\.tolist\(\), \d+\))/;
    const emaMatch = code.match(emaPattern);
    
    if (emaMatch) {
      const insertPoint = code.indexOf(emaMatch[0]) + emaMatch[0].length;
      const beforeInsert = code.substring(0, insertPoint);
      const afterInsert = code.substring(insertPoint);
      
      return `${beforeInsert}
    
    # Trend filter enhancement
    ${snippet}`;
    }
    
    // Fallback: insert at the beginning of the function
    return code.replace(/def strategy_logic\(data\):\s*\n/, `def strategy_logic(data):
    # Trend filter enhancement
    ${snippet}
    
`);
  }

  private static integrateExitStrategyLogic(code: string, snippet: string, functionMatch: RegExpMatchArray): string {
    // Insert before the main loop
    const loopPattern = /(\s+)(for i in range\(len\(data\)\):)/;
    const loopMatch = code.match(loopPattern);
    
    if (loopMatch) {
      const insertPoint = code.indexOf(loopMatch[0]);
      const beforeInsert = code.substring(0, insertPoint);
      const afterInsert = code.substring(insertPoint);
      
      return `${beforeInsert}    
    # Enhanced exit strategy
    ${snippet}
    
${afterInsert}`;
    }
    
    return code;
  }

  private static integrateRiskManagementLogic(code: string, snippet: string, functionMatch: RegExpMatchArray): string {
    // Insert at the beginning of the function after the def line
    const functionStart = code.indexOf('def strategy_logic(data):') + 'def strategy_logic(data):'.length;
    const beforeFunction = code.substring(0, functionStart);
    const afterFunction = code.substring(functionStart);
    
    return `${beforeFunction}
    # Risk Management Enhancement
    ${snippet}
${afterFunction}`;
  }

  private static integrateVolatilityFilterLogic(code: string, snippet: string, functionMatch: RegExpMatchArray): string {
    // Insert after EMA calculations
    const emaPattern = /(long_ema = TechnicalAnalysis\.ema\(data\['Close'\]\.tolist\(\), \d+\))/;
    const emaMatch = code.match(emaPattern);
    
    if (emaMatch) {
      const insertPoint = code.indexOf(emaMatch[0]) + emaMatch[0].length;
      const beforeInsert = code.substring(0, insertPoint);
      const afterInsert = code.substring(insertPoint);
      
      return `${beforeInsert}
    
    # Volatility filter
    ${snippet}${afterInsert}`;
    }
    
    return code;
  }

  private static integrateDynamicStopLossLogic(code: string, snippet: string, functionMatch: RegExpMatchArray): string {
    // Insert after EMA calculations
    const emaPattern = /(long_ema = TechnicalAnalysis\.ema\(data\['Close'\]\.tolist\(\), \d+\))/;
    const emaMatch = code.match(emaPattern);
    
    if (emaMatch) {
      const insertPoint = code.indexOf(emaMatch[0]) + emaMatch[0].length;
      const beforeInsert = code.substring(0, insertPoint);
      const afterInsert = code.substring(insertPoint);
      
      return `${beforeInsert}
    
    # Dynamic stop loss
    ${snippet}${afterInsert}`;
    }
    
    return code;
  }

  private static integrateGenericLogic(code: string, snippet: string, title: string, functionMatch: RegExpMatchArray): string {
    // Insert before the main logic but after initial calculations
    const emaPattern = /(long_ema = TechnicalAnalysis\.ema\(data\['Close'\]\.tolist\(\), \d+\))/;
    const emaMatch = code.match(emaPattern);
    
    if (emaMatch) {
      const insertPoint = code.indexOf(emaMatch[0]) + emaMatch[0].length;
      const beforeInsert = code.substring(0, insertPoint);
      const afterInsert = code.substring(insertPoint);
      
      return `${beforeInsert}
    
    # ${title} Enhancement
    ${snippet}${afterInsert}`;
    }
    
    // Fallback: insert at the beginning of the function
    return code.replace(/def strategy_logic\(data\):\s*\n/, `def strategy_logic(data):
    # ${title} Enhancement
    ${snippet}
    
`);
  }

  static insertMultipleSnippets(existingCode: string, snippets: Array<{code: string, title: string}>): string {
    let updatedCode = existingCode;
    
    snippets.forEach((snippet, index) => {
      console.log(`Inserting snippet ${index + 1}/${snippets.length}: ${snippet.title}`);
      updatedCode = this.insertCodeSnippet(updatedCode, snippet.code, snippet.title);
    });
    
    return updatedCode;
  }
}
